# 웹개발자를 위한 자바스크립트의 모든 것
### 정의, 이해관계자, 용어
자바스크립트는 Ecma International에 의해 "ECMAScript"로 표준화되었다.
### ES2015~ES2020까지 자바스크립트에 추가된 새로운 기능
- 언어에 포함된 블록 스코프(let, const): 변수에 대한 범위가 더 좁아지고, for 루프 내 범위의 영리한 처리, 값이 변경될 수 없는 "변수"(const)
- 화살표 함수: 가볍고 간결한 함수로, 호출될 때 설정된 고유한 this 값을 갖는 대신 this를 포함하기 때문에 콜백에 특히 유용함
- 함수 매개변수 개선: 기본값, 매개변수 디스트럭처링, "나머지" 매개변수, 후행 쉼표
- 이터러블 객체: 반복 가능한 객체(예: 배열과 문자열), 언어 내 반복 구조를 만들고 사용하기 위한 잘 정의된 의미 체계, 반복할 수 있는 시퀀스를 생성하기 위한 제너레이터 함수(비동기 시퀀스 포함)
- 스프레드 구문: 배열(또는 다른 이터러블) 엔트리를 새 배열로, 객체 속성을 새 객체로, 이터러블 엔트리를 개별 함수 인수로 분산하여 함수형 프로그래밍이나 불변 구조가 사용되는 모든 곳에서 특히 유용함
- 나머지 구문: 객체 속성의 나머지, 이터러블 값이나 함수 인수를 객체나 배열로 모으기
- 기타 구문 개선: 함수를 호출할 때 인수 목록에 후행 쉼표를 허용하고, catch 절에서 사용하지 않는 식별자를 생략함. 새로운 스타일의 8진수 리터럴, 이진수 리터럴, 숫자 표기 시 구분 문자, 기타 등등
- 디스트럭처링: 객체와 배열 리터럴과 유사한 간결한 방식으로 배열/객체에서 값 선택
- 클래스: 자바스크립트의 고유한 프로토타입 특성을 유지하면서 생성자 함수와 관련 프로토타입 객체를 생성하기 위한 훨씬 간단하고 선언적인 구문
- 비동기 프로그래밍 개선: Promise, 비동기 함수(async await), 콜백 지옥이 현저히 감소
- 객체 리터럴 개선: 계산된 속성 이름, 단축 속성, 메서드 구문, 속성 정의 뒤의 후행 쉼표
- 템플릿 리터럴: 동적 콘텐츠로 문자열을 만들고 태그가 지정된 템플릿 함수를 사용하여 문자열을 넘어서는 간단하고 선언적인 방법
- 타입이 있는 배열: 네이티브 API를 사용하기 위한 저수준용 배열
- 공유 메모리: 자바스크립트 스렉드 간에 메모리를 공유하는 기능
- 유니코드 문자열 개선: 유니코드 코드 포인트 이스케이프 시퀀스, 코드 단위 대신 코드 포인트 접근 지원
- 정규 표현식 개선: 후방 탐색 지정, 이름을 지정한 캡처 그룹, 인덱스 캡처, 유니코드 속성 이스케이프, 유니코드 대소문자 구분 없음
- 맵: 키가 문자열일 필요가 없는 키/값 컬렉션
- 세트: 잘 정의된 의미를 가진 고유한 값 모음
- 위크맵, 위크세트, 약한 참조: 객체에 대한 약한 참조만 보유하기 위해 포함됨
- 표준 라이브러리 추가: Object, Array, Raay.prototype, String, String.prototype, Math등에 대한 새로운 메서드
- 심볼: 보장된 고윳값
- BigInt: 임의의 정밀도 정수
- 그리고 그 외의 많은 기능들
### 블록 스코프 선언: let과 const
var와 마찬가지로 let은 변수를 선언한다.
```js
let x = 2;
x += 40;
console.log(num); // 42
```
var를 사용할 수 있는 모든 곳에서 let을 사용할 수 있다. var와 마찬가지로 let은 초기화할 필요가 없다. 이때 변숫값은 기본적으로 undefined로 설정된다.
```js
let a;
console.log(a); // undefined
```
위의 내용을 제외하면 var와 let은 매우 다르게 동작한다.

---
const는 상수를 선언한다.
```js
const value = Math.random();
console.log(value < 0.5 ? '윗면': '아랫면'); 
```
상수는 값이 변경될 수 없다는 점을 제외하면 변수와 같다.
따라서 **초기화**를 해야한다.
상수에는 기본값이 없다. 변수 대신 상수를 만들고 초기화가 필요하다는 점 외에 const는 let과 같다.
### 진짜 블록 스코프
var는 블록에서 튀어나온다. var로 블록 내에서 변수를 선언하면 해당 블록 내부뿐만 아니라 외부에서도 변수를 사용할 수 있다.
```js
function jumpOut() {
  var a = [1, 2, 3];
  for(var i = 0; i < a.length; ++i) {
    var value = a[i];
    console.log(value);
  }
  console.log('Outside loop' + value);
}
jumOut();
```
jumOut의 작성자는 아마도 루프 외부에서 값에 접근할 수 있도록 의도하지는 않았겠지만 접근할 수 있다. 왜 이것이 문제일까?
- 변수는 유지 관리를 위해 가능한 한 좁게 범위를 지정해야 한다.
필요한 만큼만 존재해야 하며 그 이후 더 이상 없어야 한다.
- 코드의 명백한 의도와 실제 효과가 다를 때마다 버그와 유지 관리 문제를 일으킨다.

let과 const는 선언된 **블록 내**에서만 존재한다.
```js
function stayContained() {
  var a = [1, 2, 3];
  for (var i = 0; i < a.length; ++i) {
    let value = a[i];
    console.log(value);
  }
  console.log('Outside loop' + value); // ReferenceError: 'value' is not defined
}
stayContained();
```
이제 value는 블록이 의미하는 대로 범위가 지정된다. 그 밖의 함수 영역에는 존재하지 않는다.
필요한 만큼만 존재하며 명백한 의도가 실제 효과와 일치한다.
